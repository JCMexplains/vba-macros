'@Folder("Cleanup")
Option Explicit

'@EntryPoint
Public Sub Format_BI_exports()
    
    ' BI_cleanup Macro
    ' Clean up export from Power BI
    
    If Not Helper_procedures.tableExist(ActiveSheet, "Table1") Then
        ' If there is no Table1, we are either on the wrong sheet or have already run this macro, so exit
        'a MessageBox is actually a number, weirdly. if you want to display any more than just a text string, you must Dim the variable
        MsgBox "This sheet has no Table1 to work on, so this macro didn't do anything.", vbInformation, "Format BI exports"
        Exit Sub
    End If
    
    Application.StatusBar = "Macro running. Press Esc to cancel."
    
    RenameSheet ' Table1 is named ClassListTable now
    
    RenameFile
    ' TODO save user search settings and restore them at the end
    
    'Turn off screen flickering as the macro runs
    Application.ScreenUpdating = False
    
    'delete all the rows before the header row
    ActiveSheet.Rows("1:" & (ActiveSheet.Range("ClassListTable[#Headers]").Row - 1)).Delete
    
    ' variables for the last used row and the last used column
    Dim lastRow     As Long
    Dim lastCol     As Long
    
    With ActiveWorkbook.Sheets("Class sections")
        lastRow = .Cells(ActiveSheet.Rows.Count, 1).End(xlUp).Row
        lastCol = .Cells(1, ActiveSheet.Columns.Count).End(xlToLeft).Column
    End With
    
    'freeze panes
    With ActiveWindow
        ' turn off freeze panes in case user has already turned it on
        If .FreezePanes Then .FreezePanes = False
        .SplitColumn = 0
        .SplitRow = 1
        .FreezePanes = True
    End With
    
    'changes names of columns to more human-friendly names, replacing anything of the form Curriculum.xyz with xyz
    'documentation for this replace function: https://docs.microsoft.com/en-us/office/vba/api/excel.range.replace
    'vbNullString is preferred over "" for indicating that you are replacing with an empty string
    ActiveSheet.ListObjects("ClassListTable").HeaderRowRange.Select
    Selection.Replace What:="Curriculum.", Replacement:=vbNullString, LookAt:=xlPart, _
                      SearchOrder:=xlByRows, MatchCase:=False, SearchFormat:=False, _
                      ReplaceFormat:=False, FormulaVersion:=xlReplaceFormula2
    
    'now replace "Division Department" with a shorter version. Header row is already selected
    Selection.Replace What:="Division Department", Replacement:="Div Dept", LookAt:=xlPart, _
                      SearchOrder:=xlByRows, MatchCase:=False, SearchFormat:=False, _
                      ReplaceFormat:=False, FormulaVersion:=xlReplaceFormula2
    
    'delete some unneeded columns
    'deleting by the name in the header rather than by column number or letter because columns seem to keep getting added to the report
    'listing all the columns we want to delete, omitting the word 'Curriculum' since I already deleted that
    Dim colsToDelete(16) As String
    Dim colName         As Variant
    colsToDelete(0) = "BC Course Discipline"
    colsToDelete(1) = "Course ID Prefix"
    colsToDelete(2) = "Course Pathway"
    colsToDelete(3) = "Credit Hrs"
    colsToDelete(4) = "Credit Type"
    colsToDelete(5) = "Department"
    colsToDelete(6) = "Division"
    colsToDelete(7) = "FTE"
    colsToDelete(8) = "Gen Ed"
    colsToDelete(9) = "ICS Code"
    colsToDelete(10) = "Outlier"
    colsToDelete(11) = "Paid FTE"
    colsToDelete(12) = "Primary Instructor ID"
    colsToDelete(13) = "Primary Instructor Type"
    colsToDelete(14) = "Std Cntct Hrs"
    colsToDelete(15) = "SummaryKey"
    colsToDelete(16) = "Term"

    
    For Each colName In colsToDelete
        Helper_procedures.SelectColumnFromTable "ClassListTable", colName
        Selection.Delete Shift:=xlToLeft
        lastCol = lastCol - 1                    'we now have one fewer used column, so we can decrement this variable
    Next colName
    
    'calling another Sub, which goes through all cells and changes any "numbers stored as text" to regular numbers
    Helper_procedures.FixNumberStoredAsText ("Class sections")
    
    'select the Sess column and format it
    Helper_procedures.SelectColumnFromTable "ClassListTable", "Sess"
    Selection.FormatConditions.AddDatabar
    With Selection.FormatConditions(1)
        .MinPoint.Modify newtype:=xlConditionValueAutomaticMin
        .MaxPoint.Modify newtype:=xlConditionValueAutomaticMax
        .BarColor.Color = 2668287
    End With
    
    'select the Enrolled column and format it
    Helper_procedures.SelectColumnFromTable "ClassListTable", "Enrolled"
    Selection.FormatConditions.AddColorScale ColorScaleType:=3
    
    'formats instructor names to have a space after the comma
    'the underscore character lets you break a long single-line statement into multiple lines
    Helper_procedures.SelectColumnFromTable "ClassListTable", "Instructor Name"
    Selection.Replace What:=",", Replacement:=", ", LookAt:=xlPart, _
                      SearchOrder:=xlByRows, MatchCase:=False, SearchFormat:=False, _
                      ReplaceFormat:=False, FormulaVersion:=xlReplaceFormula2
    
    'cleans up Delivery Method names, e.g. from RemoteLearningBlended to Remote Blended
    Helper_procedures.SelectColumnFromTable "ClassListTable", "Delivery Method"
    Selection.Replace What:="RemoteLearning", Replacement:="Remote ", LookAt:=xlPart, _
                      SearchOrder:=xlByRows, MatchCase:=False, SearchFormat:=False, _
                      ReplaceFormat:=False, FormulaVersion:=xlReplaceFormula2
    
    'sort by instructor name
    With ActiveWorkbook.Worksheets("Class sections").ListObjects("ClassListTable").Sort
        .SortFields.Clear
        .SortFields.Add2 Key:=ActiveSheet.Range("ClassListTable[[#All],[Instructor Name]]"), SortOn:=xlSortOnValues, _
        Order:=xlAscending, DataOption:=xlSortTextAsNumbers
        .Header = xlYes
        .MatchCase = False
        .Orientation = xlTopToBottom
        .Apply
    End With
    
    ' sort designators in alphbetical (ASCII-betical?) order
    Dim cellUnderInspection As Range
    Dim currentCellSorted As String
    
    Helper_procedures.SelectColumnFromTable "ClassListTable", "Designator List"
    For Each cellUnderInspection In Selection.Cells()
        currentCellSorted = SortString(cellUnderInspection.Value)
        cellUnderInspection.Value = currentCellSorted
    Next

    ' calls a Sub that will remove the trailing zero from room numbers
    ' the first argument is the column number of the column named "Rm #"
    ' the single quote before the # in Rm # is a special-character escape
    Helper_procedures.TrimTrailingZero ActiveSheet.Range("ClassListTable[[#Headers], [Rm '#]]").Column, lastRow
    
    'find the column number of the Div Dept column and store it
    Dim divDeptCol  As Long
    
    divDeptCol = ActiveSheet.Range("ClassListTable[[#Headers], [Div Dept]]").Column
    
    'unfortunately, Range.AutoFilter only lets you choose the field to filter by using an integer offset, so we use the integer we found earlier
    ActiveWorkbook.Sheets("Class sections").ListObjects("ClassListTable").Range.AutoFilter Field:=divDeptCol, Criteria1:=Array("ENG1BASE", "ENG1COPR", "ENG5BASE"), Operator:=xlFilterValues
    
    'how to select columns by number rather than by letter (doing it by letter is much easier!)
    'autofits selected columns
    ActiveSheet.Columns(1).Resize(, lastCol).EntireColumn.AutoFit
    
    'Curt Frye says it's good style to turn screen updating back on at the end of a macro, even though it's technically not necessary
    Application.ScreenUpdating = True
    
    'setting the status bar back to blank
    Application.StatusBar = vbNullString
    
End Sub

Public Function SortString(ByVal toSort As String) As String
    Dim substrings       As Variant
    Dim commaDelim As String
    commaDelim = ","
        
    'the line below puts the two-character codes into an array, delimiting with commas
    substrings = Split(Replace(toSort, " ", vbNullString), commaDelim)
    substrings = SortArray(substrings)
        
    ' whatever is assigned to the name of the function is what gets returned
    SortString = Join(substrings, commaDelim & " ")
End Function

Public Function SortArray(ByVal substrings As Variant) As Variant
    Dim temp        As Variant
    Dim firstCounter           As Long
    Dim secondCounter           As Long
        
    For firstCounter = LBound(substrings) To UBound(substrings) - 1
        For secondCounter = firstCounter + 1 To UBound(substrings)
            'Trim strips leading and trailing spaces
            'this is implementing a bubble sort, i believe
            If substrings(firstCounter) > substrings(secondCounter) Then
                'the three lines below swap firstCounter and secondCounter
                temp = substrings(firstCounter)
                substrings(firstCounter) = substrings(secondCounter)
                substrings(secondCounter) = temp
            End If
        Next secondCounter
    Next firstCounter
    SortArray = substrings
End Function

' making a sub private means it can't be called from another module and won't show up in the Macro window
Private Sub RenameSheet()
    ActiveWorkbook.Sheets(1).Name = "Class sections"
    ActiveWorkbook.Sheets("Class sections").ListObjects("Table1").Name = "ClassListTable"
End Sub

Private Sub RenameFile()
    Dim originalName As String
    originalName = ActiveWorkbook.FullName
    
    Dim termNumber As String
    termNumber = ActiveSheet.Range("ClassListTable[[#Headers], [Term]]").Offset(1, 0).Value
    
    Dim termName As String
    
    If Right$(termNumber, 1) = 1 Then
        termName = "Fall"
    ElseIf Right$(termNumber, 1) = 2 Then
        termName = "Spring"
    ElseIf Right$(termNumber, 1) = 3 Then
        termName = "Summer"
    End If
    
    Dim newName     As String
    newName = Application.ActiveWorkbook.Path & "/" & termName & " " & termNumber & " BI schedule " & MonthName(Month(Date)) & " " & Day(Date) & ".xlsx"
    
    ActiveWorkbook.SaveAs Filename:=newName, FileFormat:=xlOpenXMLWorkbook
    'including FileFormat ensures this will save as xlsx even if it was originally csv
    
    ' TODO get this to work--maybe move original file to temp folder then delete?
    On Error Resume Next
    Kill originalName 'deletes the original file -- works on local folders, won't work on a network folder--why
    On Error GoTo 0
    
End Sub


